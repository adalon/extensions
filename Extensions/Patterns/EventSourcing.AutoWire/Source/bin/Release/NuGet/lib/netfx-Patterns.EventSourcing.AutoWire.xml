<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Source</name>
    </assembly>
    <members>
        <member name="T:AggregateRoot`2">
            <devdoc>
            Provides additional behavior to the Event Sourcing Core package AggregateRoot partial class to auto wire up event handlers by using reflection.
            </devdoc>
            <nuget id="netfx-Patterns.EventSourcing.AutoWire" />
            <summary>
            Base class for domain classes that raise and optionally consume 
            as their persistence mechanism.
            </summary>
            <typeparam name="TAggregateId">The type of identifier used by the aggregate roots in the domain.</typeparam>
            <typeparam name="TBaseEvent">The base type or interface implemented by events in the domain.</typeparam>
            <nuget id="netfx-Patterns.EventSourcing" />
        </member>
        <member name="M:AggregateRoot`2.AutoWireHandlers">
            <summary>
            As an alternative to explicitly calling <see cref="M:AggregateRoot`2.Handles``1(System.Action{``0})"/> 
            from your aggregate root constructor to specify the handlers 
            for each type of event, this method will use reflection (once per type)
            to discover the handlers for events by looking for void methods with 
            a single parameter inheriting from <typeparamref name="TBaseEvent"/>
            and registering that with the <see cref="M:AggregateRoot`2.Handles``1(System.Action{``0})"/> method like 
            you would do manually.
            </summary>
            <devdoc>
            This code will hurt your eyes, but it's tunned for performance so that 
            it's as close to your own manually configured handlers as possible. 
            This is the reason why this was created as a separate optional 
            package and not part of the very simple aggregate root for plain 
            event sourcing. 
            Perf. is about 8-15x slower than manual code, but still 5x faster than 
            cached compiled lambdas and way more than plain reflection.
            </devdoc>
        </member>
        <member name="M:AggregateRoot`2.BuildInitializer">
            <devdoc>
            This code was tweaked from the base generated by 
            the Reflection.Emit language adding to Reflector 7, 
            which is the only practical way of using this way 
            of codegen. Install from http://kzu.to/nN0iPu
            </devdoc>
        </member>
        <member name="M:AggregateRoot`2.AcceptChanges">
            <summary>
            Clears the internal events retrieved from <see cref="M:AggregateRoot`2.GetChanges"/>, 
            signaling that all pending events have been commited.
            </summary>
        </member>
        <member name="M:AggregateRoot`2.GetChanges">
            <summary>
            Gets the pending changes.
            </summary>
        </member>
        <member name="M:AggregateRoot`2.Load(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Loads the the domain object from an even stream.
            </summary>
        </member>
        <member name="M:AggregateRoot`2.Handles``1(System.Action{``0})">
            <summary>
            Configures a handler for an event. 
            </summary>
        </member>
        <member name="M:AggregateRoot`2.Raise``1(``0)">
            <summary>
            Applies a change to the entity state via an event. 
            The derived class should invoke <see cref="M:AggregateRoot`2.Handles``1(System.Action{``0})"/> 
            to configure the handlers for specific types of events. The 
            handlers perform the actual state changes to the entity.
            </summary>
        </member>
        <member name="P:AggregateRoot`2.Id">
            <summary>
            Gets or sets the identifier of the domain object sourcing the event.
            </summary>
        </member>
        <member name="T:DomainEventBus`2">
            <summary>
            Default implementation of an <see cref="T:IDomainEventBus`2"/> that 
            invokes handlers as events are published, and where handlers are 
            run in-process (if any handlers are provided).
            </summary>
            <remarks>
            A persistent <see cref="T:IDomainEventStore`2"/> can also be specified 
            to persist events to a store for later playback or auditing.
            <para>
            Handlers with <see cref="P:IDomainEventHandler.IsAsync"/> set to 
            <see langword="true"/> are invoked through the optional 
            async runner delegate passed to the constructor.
            </para>
            </remarks>
            <typeparam name="TAggregateId">The type of identifier used by the aggregate roots in the domain.</typeparam>
            <typeparam name="TBaseEvent">The base type or interface implemented by events in the domain.</typeparam>
            <nuget id="netfx-Patterns.EventSourcing"/>
        </member>
        <member name="T:IDomainEventBus`2">
            <summary>
            Interface implemented by the component that coordinates 
            event handler invocation when a subscribed event is published.
            </summary>
            <typeparam name="TAggregateId">The type of identifier used by the aggregate roots in the domain.</typeparam>
            <typeparam name="TBaseEvent">The base type or interface implemented by events in the domain.</typeparam>
            <nuget id="netfx-Patterns.EventSourcing"/>
        </member>
        <member name="M:IDomainEventBus`2.Publish(AggregateRoot{`0,`1},`1)">
            <summary>
            Publishes the specified event to the bus so that all subscribers are notified.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="args">The event payload.</param>
        </member>
        <member name="M:DomainEventBus`2.#cctor">
            <summary>
            Initializes the <see cref="P:DomainEventBus`2.None"/> null object 
            pattern property.
            </summary>
        </member>
        <member name="M:DomainEventBus`2.#ctor(IDomainEventStore{`0,`1})">
            <summary>
            Initializes a new instance of the <see cref="T:DomainEventBus`2"/> class
            with a persistent store for events and no in-memory handlers.
            </summary>
            <param name="eventStore">The event store to persist events to.</param>
        </member>
        <member name="M:DomainEventBus`2.#ctor(System.Collections.Generic.IEnumerable{IDomainEventHandler})">
            <summary>
            Initializes a new instance of the <see cref="T:DomainEventBus`2"/> class with 
            the default async runner that enqueues work in the <see cref="T:System.Threading.ThreadPool"/>.
            </summary>
            <param name="eventHandlers">The event handlers.</param>
        </member>
        <member name="M:DomainEventBus`2.#ctor(IDomainEventStore{`0,`1},System.Collections.Generic.IEnumerable{IDomainEventHandler})">
            <summary>
            Initializes a new instance of the <see cref="T:DomainEventBus`2"/> class with 
            a persistent store for events and the default async runner that enqueues work in the <see cref="T:System.Threading.ThreadPool"/>.
            </summary>
            <param name="eventStore">The event store to persist events to.</param>
            <param name="eventHandlers">The event handlers.</param>
        </member>
        <member name="M:DomainEventBus`2.#ctor(System.Collections.Generic.IEnumerable{IDomainEventHandler},System.Action{System.Action})">
            <summary>
            Initializes a new instance of the <see cref="T:DomainEventBus`2"/> class with 
            the given async runner.
            </summary>
            <param name="eventHandlers">The event handlers.</param>
            <param name="asyncActionRunner">The async action runner to use to invoke event handlers 
            that have <see cref="P:DomainEventHandler.IsAsync"/> set to <see langword="true"/>.</param>
        </member>
        <member name="M:DomainEventBus`2.#ctor(IDomainEventStore{`0,`1},System.Collections.Generic.IEnumerable{IDomainEventHandler},System.Action{System.Action})">
            <summary>
            Initializes a new instance of the <see cref="T:DomainEventBus`2"/> class with 
            a persistent store for events, a set of event handlers and a specific async runner.
            </summary>
            <param name="eventStore">The event store to persist events to.</param>
            <param name="eventHandlers">The event handlers.</param>
            <param name="asyncActionRunner">The async action runner to use to invoke event handlers 
            that have <see cref="P:DomainEventHandler.IsAsync"/> set to <see langword="true"/>.</param>
        </member>
        <member name="M:DomainEventBus`2.Publish(AggregateRoot{`0,`1},`1)">
            <summary>
            Publishes the specified event to the bus so that all subscribers are notified.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="args">The event payload.</param>
        </member>
        <member name="P:DomainEventBus`2.None">
            <summary>
            Gets a default domain event bus implementation that 
            does nothing (a.k.a. Null Object Pattern).
            </summary>
        </member>
        <member name="T:DomainEventBus`2.NullBus">
            <summary>
            Provides a null <see cref="T:IDomainEventBus`2"/> implementation 
            for use when no events have been configured.
            </summary>
        </member>
        <member name="M:DomainEventBus`2.NullBus.Publish(AggregateRoot{`0,`1},`1)">
            <summary>
            Does nothing.
            </summary>
        </member>
        <member name="T:IDomainEventStore`2">
            <summary>
            Interface implemented by domain event stores.
            </summary>
            <typeparam name="TAggregateId">The type of identifier used by the aggregate roots in the domain.</typeparam>
            <typeparam name="TBaseEvent">The base type or interface implemented by events in the domain.</typeparam>
            <nuget id="netfx-Patterns.EventSourcing"/>
        </member>
        <member name="T:IEventStore`1">
            <summary>
            Interface implemented by domain event stores.
            </summary>
            <typeparam name="TBaseEvent">The base type or interface implemented by events in the system.</typeparam>
            <nuget id="netfx-Patterns.EventStore"/>
        </member>
        <member name="M:IEventStore`1.Persist(`0)">
            <summary>
            Notifies the store that the given event
            should be persisted when <see cref="M:IEventStore`1.Commit"/> is called.
            </summary>
            <param name="event">The instance containing the event data.</param>
        </member>
        <member name="M:IEventStore`1.Query(EventQueryCriteria)">
            <summary>
            Queries the event store for events that match the given criteria.
            </summary>
            <remarks>
            Store implementations are advised to provide full support for the 
            specified criteria, but aren't required to.
            <para>
            The more user-friendly querying API in <see cref="T:IEventQuery`1"/> 
            provides a fluent API over any store to build the criteria object, 
            and can therefore be used with any event store implementation. 
            It's accessible by executing the 
            <see cref="M:EventQueryExtensions.Query``1(IEventStore{``0})"/> extension method
            on an event store instance.
            </para>
            </remarks>
        </member>
        <member name="M:IEventStore`1.Commit">
            <summary>
            Persists all events <see cref="M:IEventStore`1.Persist(`0)"/>ed so far, effectively commiting 
            the changes to the underlying store in a unit-of-work style.
            </summary>
        </member>
        <member name="M:IDomainEventStore`2.Persist(AggregateRoot{`0,`1},`1)">
            <summary>
            Notifies the store that the given event raised by the given sender 
            should be persisted when <see cref="M:IEventStore`1.Commit"/> is called.
            </summary>
            <param name="sender">The sender of the event.</param>
            <param name="args">The instance containing the event data.</param>
        </member>
        <member name="M:IDomainEventStore`2.Query(DomainEventQueryCriteria{`0})">
            <summary>
            Queries the event store for events that match the given criteria.
            </summary>
            <remarks>
            Store implementations are advised to provide full support for the 
            specified criteria, but aren't required to.
            <para>
            The more user-friendly querying API in <see cref="T:IDomainEventQuery`2"/> 
            provides a fluent API over any store to build the criteria object, 
            and can therefore be used with any event store implementation. 
            It's accessible by executing the 
            <see cref="M:DomainEventQueryBuilder.Query``2(IDomainEventStore{``0,``1})"/> extension method
            on a domain event store instance.
            </para>
            </remarks>
        </member>
        <member name="T:DomainEventHandler">
            <summary>
            Base class part of the infrastructure. Concrete 
            handlers should inherit <see cref="T:DomainEventHandler`2"/> instead or 
            implement <see cref="T:IDomainEventHandler`2"/> directly.
            </summary>
            <nuget id="netfx-Patterns.EventSourcing"/>
        </member>
        <member name="T:IDomainEventHandler">
            <summary>
            Base interface part of the infrastructure. Concrete 
            handlers should inherit <see cref="T:DomainEventHandler`2"/> 
            or implement <see cref="T:IDomainEventHandler`2"/> instead.
            </summary>
            <nuget id="netfx-Patterns.EventSourcing"/>
        </member>
        <member name="P:IDomainEventHandler.IsAsync">
            <summary>
            Invocation style hint that the <see cref="T:IDomainEventBus`2"/> implementation
            can use to invoke a handler asynchronously with regards to the event publisher.
            </summary>
        </member>
        <member name="P:IDomainEventHandler.EventType">
            <summary>
            Gets the type of the event argument this handler can process.
            </summary>
        </member>
        <member name="P:DomainEventHandler.IsAsync">
            <summary>
            Invocation style hint that the <see cref="T:IDomainEventBus`2"/> implementation
            can use to invoke a handler asynchronously with regards to the event publisher.
            </summary>
        </member>
        <member name="P:DomainEventHandler.EventType">
            <summary>
            Gets the type of the event argument this handler can process.
            </summary>
        </member>
        <member name="T:DomainEventHandler`2">
            <summary>
            Base class for domain event handlers that handle a specific type of event.
            </summary>
            <typeparam name="TAggregateId">The type of identifier used by the aggregate roots in the domain.</typeparam>
            <typeparam name="TEventArgs">Type of event argument this handler can process.</typeparam>
            <nuget id="netfx-Patterns.EventSourcing" />
        </member>
        <member name="T:IDomainEventHandler`2">
            <summary>
            Base interface for domain event handlers that handle a specific type of event.
            </summary>
            <typeparam name="TAggregateId">The type of identifier used by the aggregate roots in the domain.</typeparam>
            <typeparam name="TEventArgs">Type of event argument this handler can process.</typeparam>
            <nuget id="netfx-Patterns.EventSourcing" />
        </member>
        <member name="M:IDomainEventHandler`2.Handle(`0,`1)">
            <summary>
            Handles the specified event.
            </summary>
        </member>
        <member name="M:DomainEventHandler`2.Handle(`0,`1)">
            <summary>
            Handles the specified event.
            </summary>
        </member>
        <member name="P:DomainEventHandler`2.EventType">
            <summary>
            Gets the type of the event this handler can process, which equals 
            the generic type parameter of <see cref="T:DomainEventHandler`2"/>.
            </summary>
        </member>
        <member name="T:DomainEventQueryBuilder">
            <summary>
            Provides the entry point <see cref="M:DomainEventQueryBuilder.Query``2(IDomainEventStore{``0,``1})"/> for a fluent API 
            that makes querying event stores easier.
            </summary>
            <nuget id="netfx-Patterns.EventSourcing"/>
        </member>
        <member name="M:DomainEventQueryBuilder.Query``2(IDomainEventStore{``0,``1})">
            <summary>
            Queries the event store for events that match specified 
            criteria via the returned fluent API methods 
            <see cref="M:IDomainEventQuery`2.For``1"/> and 
            <see cref="M:IDomainEventQuery`2.OfType``1"/>. 
            </summary>
            <typeparam name="TAggregateId">The type of identifier used by the aggregate roots in the domain.</typeparam>
            <typeparam name="TBaseEvent">The base type or interface implemented by events in the domain.</typeparam>
            <param name="store">The domain event store.</param>
        </member>
        <member name="T:IDomainEventQuery`2">
            <summary>
            Provides a fluent API to filter events from the event store. 
            </summary>
            <remarks>
            This interface is returned from the <see cref="M:DomainEventQueryBuilder.Query``2(IDomainEventStore{``0,``1})"/> 
            extension method for <see cref="T:IDomainEventStore`2"/>.
            </remarks>
            <typeparam name="TAggregateId">The type of identifier used by the aggregate roots in the domain.</typeparam>
            <typeparam name="TBaseEvent">The base type or interface implemented by events in the domain.</typeparam>
            <nuget id="netfx-Patterns.EventSourcing"/>
        </member>
        <member name="M:IDomainEventQuery`2.For``1">
            <summary>
            Filters events that target the given aggregate root type. Can be called 
            multiple times and will filter for any of the specified types (OR operator).
            </summary>
            <typeparam name="TAggregate">The type of the aggregate root to filter events for.</typeparam>
        </member>
        <member name="M:IDomainEventQuery`2.For``1(`0)">
            <summary>
            Filters events that target the given aggregate root type and identifier. Can be called 
            multiple times and will filter for any of the specified types and ids (OR operator).
            </summary>
            <typeparam name="TAggregate">The type of the aggregate root to filter events for.</typeparam>
            <param name="aggregateId">The aggregate root identifier to filter by.</param>
        </member>
        <member name="M:IDomainEventQuery`2.OfType``1">
            <summary>
            Filters events that are assignable to the given type. Can be called 
            multiple times and will filter for any of the specified types (OR operator).
            </summary>
            <typeparam name="TEvent">The type of the events to filter.</typeparam>
        </member>
        <member name="M:IDomainEventQuery`2.Since(System.DateTime)">
            <summary>
            Filters events that happened after the given starting date.
            </summary>
            <param name="when">The starting date to filter by.</param>
            <remarks>
            By default, includes events with the given date, unless the 
            <see cref="M:IDomainEventQuery`2.ExclusiveRange"/> is called to make the range exclusive.
            </remarks>
        </member>
        <member name="M:IDomainEventQuery`2.Until(System.DateTime)">
            <summary>
            Filters events that happened before the given ending date.
            </summary>
            <param name="when">The ending date to filter by.</param>
            <remarks>
            By default, includes events with the given date, unless the 
            <see cref="M:IDomainEventQuery`2.ExclusiveRange"/> is called to make the range exclusive.
            </remarks>
        </member>
        <member name="M:IDomainEventQuery`2.ExclusiveRange">
            <summary>
            Makes the configured <see cref="M:IDomainEventQuery`2.Since(System.DateTime)"/> and/or <see cref="M:IDomainEventQuery`2.Until(System.DateTime)"/> dates 
            exclusive, changing the default behavior which is to be inclusive.
            </summary>
        </member>
        <member name="P:IDomainEventQuery`2.Criteria">
            <summary>
            Gets the criteria that was built using the fluent API so far.
            </summary>
        </member>
        <member name="M:DomainEventQueryBuilder.DomainEventQuery`2.GetInheritance``1">
            <devdoc>
            Returns a list of the T and all its base types until an 
            abstract base class is found (can't be persisted therefore) 
            or System.Object is found (events can't be System.Object either).
            </devdoc>
        </member>
        <member name="T:DomainEventQueryCriteria`1">
            <summary>
            Represents the filter criteria for a domain event store query.
            </summary>
            <typeparam name="TAggregateId">The type of identifier used by the aggregate roots in the domain.</typeparam>
            <nuget id="netfx-Patterns.EventSourcing"/>
        </member>
        <member name="T:EventQueryCriteria">
            <summary>
            Represents the filter criteria for an event store query.
            </summary>
            <nuget id="netfx-Patterns.EventStore"/>
        </member>
        <member name="M:EventQueryCriteria.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:EventQueryCriteria"/> class.
            </summary>
        </member>
        <member name="P:EventQueryCriteria.EventTypes">
            <summary>
            List of event type filters. All types added are OR'ed with the 
            others (i.e. <c>EventType == ProductCreated OR EventType == ProductPublished</c>).
            </summary>
        </member>
        <member name="P:EventQueryCriteria.Since">
            <summary>
            Filters events that happened after the given starting date.
            </summary>
        </member>
        <member name="P:EventQueryCriteria.Until">
            <summary>
            Filters events that happened before the given ending date.
            </summary>
        </member>
        <member name="P:EventQueryCriteria.IsExclusiveRange">
            <summary>
            If set to <see langword="true"/>, <see cref="P:EventQueryCriteria.Since"/> and <see cref="P:EventQueryCriteria.Until"/> should 
            be considered as exclusive ranges (excludes values with a matching date). 
            Defaults to <see langword="false"/>, meaning that ranges are inclusive by default.
            </summary>
        </member>
        <member name="M:DomainEventQueryCriteria`1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:DomainEventQueryCriteria`1"/> class.
            </summary>
        </member>
        <member name="P:DomainEventQueryCriteria`1.AggregateInstances">
            <summary>
            List of source object type + instance identifier filters. The two filters 
            should be considered by event stores as AND'ed (i.e. 
            events for <c>Product AND Id = 5</c>) and each entry is OR'ed with the 
            others (i.e. <c>(Product AND Id = 5) OR (Order AND Id = 1)</c>.
            </summary>
        </member>
        <member name="P:DomainEventQueryCriteria`1.AggregateTypes">
            <summary>
            List of aggregate root type filters. All types added are OR'ed with the 
            others (i.e. <c>AggregateType == Product OR AggregateType == Order</c>).
            </summary>
            <remarks>
            To filter by aggregate type and identifier, 
            use <see cref="P:DomainEventQueryCriteria`1.AggregateInstances"/> instead.
            </remarks>
        </member>
        <member name="T:DomainEventQueryCriteria`1.AggregateFilter">
            <summary>
            Filter criteria containing the aggregate type and identifier. 
            </summary>
        </member>
        <member name="M:DomainEventQueryCriteria`1.AggregateFilter.#ctor(System.Type,`0)">
            <summary>
            Initializes a new instance of the <see cref="T:DomainEventQueryCriteria`1.AggregateFilter"/> class.
            </summary>
            <param name="aggregateType">Type of the event source to filter by.</param>
            <param name="aggregateId">The aggregate root identifier to filter by.</param>
        </member>
        <member name="P:DomainEventQueryCriteria`1.AggregateFilter.AggregateType">
            <summary>
            Gets or sets the type of the aggregate to filter by.
            </summary>
        </member>
        <member name="P:DomainEventQueryCriteria`1.AggregateFilter.AggregateId">
            <summary>
            Gets or sets the aggregate root identifier to filter by.
            </summary>
        </member>
        <member name="T:EventQueryExtensions">
            <summary>
            Provides the entry point <see cref="M:EventQueryExtensions.Query``1(IEventStore{``0})"/> for a fluent API 
            that makes building the event store query criteria easier.
            </summary>
            <nuget id="netfx-Patterns.EventStore"/>
        </member>
        <member name="M:EventQueryExtensions.Query``1(IEventStore{``0})">
            <summary>
            Allows building a query against the event store 
            using a fluent API and automatically executing 
            it to find events that match built criteria upon 
            query enumeration or execution.
            </summary>
            <typeparam name="TBaseEvent">The base type or interface implemented by events in the system.</typeparam>
            <param name="store">The domain event store.</param>
        </member>
        <member name="T:IEventQuery`1">
            <summary>
            Provides a fluent API to filter events from the event store. 
            </summary>
            <remarks>
            This interface is returned from the <see cref="M:EventQueryExtensions.Query``1(IEventStore{``0})"/> 
            extension method for <see cref="T:IEventStore`1"/>.
            </remarks>
            <typeparam name="TBaseEvent">The base type or interface implemented by events in the system.</typeparam>
            <nuget id="netfx-Patterns.EventStore"/>
        </member>
        <member name="M:IEventQuery`1.Execute">
            <summary>
            Executes the <see cref="P:IEventQuery`1.Criteria"/> built using the fluent API 
            against the underlying store.
            </summary>
        </member>
        <member name="M:IEventQuery`1.OfType``1">
            <summary>
            Filters events that are assignable to the given type. Can be called 
            multiple times and will filter for any of the specified types (OR operator).
            </summary>
            <typeparam name="TEvent">The type of the events to filter.</typeparam>
        </member>
        <member name="M:IEventQuery`1.Since(System.DateTime)">
            <summary>
            Filters events that happened after the given starting date.
            </summary>
            <param name="when">The starting date to filter by.</param>
            <remarks>
            By default, includes events with the given date, unless the 
            <see cref="M:IEventQuery`1.ExclusiveRange"/> is called to make the range exclusive.
            </remarks>
        </member>
        <member name="M:IEventQuery`1.Until(System.DateTime)">
            <summary>
            Filters events that happened before the given ending date.
            </summary>
            <param name="when">The ending date to filter by.</param>
            <remarks>
            By default, includes events with the given date, unless the 
            <see cref="M:IEventQuery`1.ExclusiveRange"/> is called to make the range exclusive.
            </remarks>
        </member>
        <member name="M:IEventQuery`1.ExclusiveRange">
            <summary>
            Makes the configured <see cref="M:IEventQuery`1.Since(System.DateTime)"/> and/or <see cref="M:IEventQuery`1.Until(System.DateTime)"/> dates 
            exclusive, changing the default behavior which is to be inclusive.
            </summary>
        </member>
        <member name="P:IEventQuery`1.Criteria">
            <summary>
            Gets the criteria that was built using the fluent API so far.
            </summary>
        </member>
        <member name="T:DictionaryGetOrAdd">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Generic.IDictionary`2"/> if the key does not already exist. 
            </summary>
        </member>
        <member name="M:DictionaryGetOrAdd.GetOrAdd``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Generic.IDictionary`2"/> if the key does not already exist. 
            No locking occurs, so the value may be calculated twice on concurrent scenarios. If you need 
            concurrency assurances, use a concurrent dictionary instead.
            </summary>
        </member>
        <member name="T:Guard">
            <summary>
            Common guard class for argument validation.
            </summary>
        </member>
        <member name="M:Guard.NotNull``1(System.Linq.Expressions.Expression{System.Func{``0}},``0)">
            <summary>
            Ensures the given <paramref name="value"/> is not null.
            Throws <see cref="T:System.ArgumentNullException"/> otherwise.
            </summary>
        </member>
        <member name="M:Guard.NotNullOrEmpty(System.Linq.Expressions.Expression{System.Func{System.String}},System.String)">
            <summary>
            Ensures the given string <paramref name="value"/> is not null or empty.
            Throws <see cref="T:System.ArgumentNullException"/> in the first case, or 
            <see cref="T:System.ArgumentException"/> in the latter.
            </summary>
        </member>
    </members>
</doc>
